package com.transaction.application.usecase.transaction;

import com.transaction.application.command.CreateTransactionCommand;
import com.transaction.domain.event.DomainEvent;
import com.transaction.domain.exception.Errors;
import com.transaction.domain.exception.ServiceException;
import com.transaction.domain.model.Transaction;
import com.transaction.domain.port.output.EventPublisher;
import com.transaction.domain.port.output.TransactionRepository;
import io.quarkus.hibernate.reactive.panache.common.WithTransaction;
import io.quarkus.logging.Log;
import io.smallrye.mutiny.Uni;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import jakarta.inject.Named;

@ApplicationScoped
public class CreateTransactionUseCase {

    @Inject
    TransactionRepository transactionRepository;

    @Inject
    @Named("redisPublisher")
    EventPublisher<DomainEvent<Transaction>> eventPublisher;

    @WithTransaction
    public Uni<Transaction> execute(CreateTransactionCommand command) {
        return Uni.createFrom().item(command::toTransaction)
                .flatMap(transaction -> transactionRepository.save(transaction))
                .chain(this::publishDomainEvents)
                .onFailure().transform(CreateTransactionUseCase::transformToServiceException)
                .onItem().invoke(saved -> Log.info("Transaction saved for ticker %s".formatted(saved.getTicker())));
    }

    /**
     * Publishes all domain events generated by the transaction.
     *
     * @param transaction the transaction with generated domain events
     * @return Uni<Transaction> the same transaction after events are published
     */
    private Uni<Transaction> publishDomainEvents(Transaction transaction) {
        var events = transaction.popEvents(); // Get and clear domain events

        if (events.isEmpty()) {
            return Uni.createFrom().item(transaction);
        }

        // Publish events sequentially (could be made parallel if needed)
        Uni<Void> publishChain = Uni.createFrom().voidItem();

        for (var event : events) {
            publishChain = publishChain.chain(ignored ->
                    eventPublisher.publish((DomainEvent<Transaction>) event)
                            .onFailure().transform(failure -> {
                                Log.error("Failed to publish domain event for transaction %s".formatted(transaction.getId()), failure);
                                return new ServiceException(Errors.CreateTransaction.PUBLISH_DOMAIN_EVENT_ERROR, failure);
                            })
            );
        }

        return publishChain.map(ignored -> transaction);
    }

    private static ServiceException transformToServiceException(Throwable throwable) {
        return throwable instanceof ServiceException serviceException ? serviceException : new ServiceException(Errors.CreateTransaction.GENERAL_ERROR, throwable);
    }
} 