package com.transaction.application.usecase.transaction;

import com.transaction.application.command.CreateTransactionCommand;
import com.transaction.domain.event.DomainEvent;
import com.transaction.domain.exception.Errors;
import com.transaction.domain.exception.ServiceException;
import com.transaction.domain.model.Transaction;
import com.transaction.domain.port.output.EventPublisher;
import com.transaction.domain.port.output.TransactionRepository;
import io.quarkus.hibernate.reactive.panache.common.WithTransaction;
import io.quarkus.logging.Log;
import io.smallrye.mutiny.Uni;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;

/**
 * Application service for creating transactions.
 * <p>
 * Follows hexagonal architecture principles by orchestrating domain operations
 * and publishing domain events through output ports.
 */
@ApplicationScoped
public class CreateTransactionUseCase {

    @Inject
    TransactionRepository transactionRepository;

    @Inject
    EventPublisher<DomainEvent<Transaction>> eventPublisher;

    @WithTransaction
    public Uni<Transaction> execute(CreateTransactionCommand command) {
        return Uni.createFrom().item(command::toTransaction)
                .flatMap(transaction -> transactionRepository.save(transaction))
                .chain(this::publishDomainEvents)
                .onFailure().transform(throwable -> new ServiceException(Errors.CreateTransaction.PERSISTENCE_ERROR, throwable))
                .onItem().invoke(saved -> Log.info("Transaction saved for ticker %s".formatted(saved.getTicker())));
    }

    /**
     * Publishes all domain events generated by the transaction.
     * 
     * @param transaction the transaction with generated domain events
     * @return Uni<Transaction> the same transaction after events are published
     */
    private Uni<Transaction> publishDomainEvents(Transaction transaction) {
        var events = transaction.popEvents(); // Get and clear domain events
        
        if (events.isEmpty()) {
            return Uni.createFrom().item(transaction);
        }

        // Publish events sequentially (could be made parallel if needed)
        Uni<Void> publishChain = Uni.createFrom().voidItem();
        
        for (var event : events) {
            publishChain = publishChain.chain(ignored -> 
                eventPublisher.publish((DomainEvent<Transaction>) event)
                    .onFailure().transform(failure -> {
                        Log.error("Failed to publish domain event for transaction %s".formatted(transaction.getId()), failure);
                        return new ServiceException(Errors.CreateTransaction.PERSISTENCE_ERROR, failure);
                    })
            );
        }

        return publishChain.map(ignored -> transaction);
    }
} 